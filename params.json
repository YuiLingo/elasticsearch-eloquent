{
  "name": "Elasticsearch Eloquent",
  "tagline": "Elasticsearch functionality like Laravel Eloquent models",
  "body": "# Persimmon / Elasticsearch Eloquent\r\n\r\n[![Latest Version on Packagist][ico-version]][link-packagist]\r\n[![Software License][ico-license]](LICENSE.md)\r\n[![Build Status][ico-travis]][link-travis]\r\n[![Coverage Status][ico-scrutinizer]][link-scrutinizer]\r\n[![Quality Score][ico-code-quality]][link-code-quality]\r\n[![Total Downloads][ico-downloads]][link-downloads]\r\n\r\nThis package allows you to interact with Elasticsearch as you interact with Eloquent models in Laravel.  \r\nFeel free to improve the project.\r\n\r\n## Install\r\n\r\nVia Composer\r\n\r\n```bash\r\n$ composer require isswp101/elasticsearch-eloquent\r\n```\r\n\r\n## Usage\r\n\r\n### Configure dependencies\r\n\r\n> **Warning!** First of all you should create a base model and inherit from it their models.\r\n\r\n```php\r\nuse Elasticsearch\\Client;\r\nuse Isswp101\\Persimmon\\DAL\\ElasticsearchDAL;\r\nuse Isswp101\\Persimmon\\ElasticsearchModel as Model;\r\nuse Isswp101\\Persimmon\\Event\\EventEmitter;\r\n\r\nclass ElasticsearchModel extends Model\r\n{\r\n    public function __construct(array $attributes = [])\r\n    {\r\n        $dal = new ElasticsearchDAL($this, app(Client::class), app(EventEmitter::class));\r\n\r\n        parent::__construct($dal, $attributes);\r\n    }\r\n\r\n    public static function createInstance()\r\n    {\r\n        return new static();\r\n    }\r\n}\r\n```\r\n\r\nIn this example we use Laravel IoC Container to resolve `Elasticsearch\\Client` dependency as `app(Client::class)`.\r\n\r\n### Create a new model\r\n\r\nYou must override static variables `index` and `type` to determine the document path.\r\n\r\n```php\r\nclass Product extends ElasticsearchModel\r\n{\r\n    protected static $_index = 'test';\r\n    protected static $_type = 'test';\r\n\r\n    public $name;\r\n    public $price = 0;\r\n}\r\n```\r\n\r\nHere `name` and `price` are fields which will be stored in Elasticsearch.  \r\n> **Warning!** Don't use field names starting with underscore `$_*`, for example `$_name`.\r\n\r\nUse the static `create()` method to create document in Elasticsearch:\r\n\r\n```php\r\n$product = Product::create(['id' => 3, 'name' => 'Product 3', 'price' => 30]);\r\n```\r\n\r\n### Save the model\r\n\r\n```php\r\n$product = new Product();\r\n$product->id = 1;\r\n$product->name = 'Product 1';\r\n$product->price = 20;\r\n$product->save();\r\n```\r\n\r\nUse `save()` method to store model data in Elasticsearch. Let's see how this looks in Elasticsearch:\r\n\r\n```json\r\n{\r\n   \"_index\": \"test\",\r\n   \"_type\": \"test\",\r\n   \"_id\": \"1\",\r\n   \"_version\": 1,\r\n   \"found\": true,\r\n   \"_source\": {\r\n      \"name\": \"Product 1\",\r\n      \"price\": 10,\r\n      \"id\": 1,\r\n      \"user_id\": null,\r\n      \"created_at\": \"2016-06-03 08:11:08\",\r\n      \"updated_at\": \"2016-06-03 08:11:08\"\r\n   }\r\n}\r\n```\r\n\r\nFields `created_at` and `updated_at` were created automatically. The `user_id` field is persistent field to store user id.\r\n\r\n### Find existing model\r\n\r\n```php\r\n$product = Product::find(1);\r\n```\r\n\r\nIf you have big data in Elasticsearch you can specify certain fields to retrieve:\r\n\r\n```php\r\n$product = Product::find(1, ['name']);\r\n```\r\n\r\nIn this case the `price` field equals `0` because it's populated as the default value that you specified in the model.\r\n\r\nThere are the following methods:\r\n* `findOrFail()` returns `ModelNotFoundException` exception if no result found.\r\n* `findOrNew()` returns a new model if no result found.\r\n\r\n### Model cache\r\n\r\nThere is a smart model cache when you use methods like `find()`, `findOrFail()` and so on.\r\n\r\n```php\r\n$product = Product::find(1, ['name']);  // will be retrieved from the elasticsearch\r\n$product = Product::find(1, ['name']);  // will be retrieved from the cache\r\n$product = Product::find(1, ['price']); // elasticsearch\r\n$product = Product::find(1, ['price']); // cache\r\n$product = Product::find(1, ['name']);  // cache\r\n```\r\n\r\n```php\r\n$product = Product::findOrFail(1);      // elasticsearch\r\n$product = Product::find(1);            // cache\r\n$product = Product::find(1, ['name']);  // cache\r\n$product = Product::find(1, ['price']); // cache\r\n```\r\n\r\n### Partial update\r\n\r\nYou can use partial update to update specific fields quickly.\r\n\r\n```php\r\n$product = Product::find(1, ['name']);\r\n$product->name = 'Product 3';\r\n$product->save('name');\r\n```\r\n\r\n### Delete models\r\n\r\n```php\r\n$product = Product::find(1);\r\n$product->delete();\r\n```\r\n\r\nYou can use the static method:\r\n\r\n```php\r\nProduct::destroy(1);\r\n```\r\n\r\n### Model events\r\n\r\nOut of the box you are provided with a simple implementation of events.  \r\nYou can override the following methods to define events:\r\n\r\n* `saving()` is called before saving, updating, creating the model\r\n* `saved()` is called after saving, updating, creating the model\r\n* `deleting()` is called before deleting the model\r\n* `deleted()` is called after deleting the model\r\n\r\nFor example:\r\n\r\n```php\r\nclass Product extends ElasticsearchModel\r\n{\r\n    public static $_index = 'test';\r\n    public static $_type = 'test';\r\n\r\n    public $name;\r\n    public $price = 0;\r\n\r\n    protected function saving()\r\n    {\r\n        if ($this->price <= 0) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    protected function deleting()\r\n    {\r\n        if (!$this->canDelete()) {\r\n            throw new LogicException('No permissions to delete the model');\r\n        }\r\n\r\n        return true;\r\n    }\r\n}\r\n```\r\n\r\n### Basic search\r\n\r\nThere are helpers to search documents:\r\n\r\nThe `first($query)` method returns the first document according to the query or `null`.  \r\n\r\n```php\r\n$product = Product::first($query);\r\n```\r\n\r\nThe `firstOrFail($query)` method returns `ModelNotFoundException` exception if `first($query)` returns `null`.\r\n\r\n```php\r\n$product = Product::firstOrFail($query);\r\n```\r\n\r\nThe `search($query)` method returns documents (default 50 items) according to the query.\r\n\r\n```php\r\n$products = Product::search($query);\r\n```\r\n\r\nThe `map($query, callable $callback)` method returns all documents (default 50 items per request) according to the query.\r\n\r\n```php\r\n$total = Product::map([], function (Product $product) {\r\n    // ...\r\n});\r\n```\r\n\r\nThe `all($query)` method returns all documents according to the query.\r\n\r\n```php\r\n$products = Product::all($query);\r\n```\r\n\r\nIf `$query` is not passed the query will be as `match_all` query.\r\n\r\n### Query Builder\r\n\r\n```php\r\nuse Isswp101\\Persimmon\\QueryBuilder\\QueryBuilder;\r\n\r\n$query = new QueryBuilder();\r\n```\r\n\r\nSimple usage:\r\n\r\n```php\r\n$query = new QueryBuilder(['query' => ['match' => ['name' => 'Product']]]);\r\n$products = Product::search($query);\r\n```\r\n\r\nThe `match` query:\r\n\r\n```php\r\n$query = new QueryBuilder();\r\n$query->match('name', 'Product');\r\n$products = Product::search($query);    \r\n```\r\n\r\nThe `range` query:\r\n\r\n```php\r\n$query = new QueryBuilder();\r\n$query->betweenOrEquals('price', 20, 30)->greaterThan('price', 15);\r\n$products = Product::search($query);\r\n```\r\n\r\n### Filters\r\n\r\nFeel free to add your own filters.\r\n\r\nThe `TermFilter` filter:\r\n\r\n```php\r\n$query = new QueryBuilder();\r\n$query->filter(new TermFilter('name', '2'));\r\n$products = Product::search($query);\r\n```\r\n\r\nThe `IdsFilter` filter:\r\n\r\n```php\r\n$query = new QueryBuilder();\r\n$query->filter(new IdsFilter([1, 3]));\r\n$products = Product::search($query);\r\n```\r\n\r\nThe `RangeOrExistFilter` filter:\r\n\r\n```php\r\n$query = new QueryBuilder();\r\n$query->filter(new RangeOrExistFilter('price', ['gte' => 20]));\r\n$products = Product::search($query);\r\n```\r\n\r\n### Aggregations\r\n\r\nFeel free to add your own aggregations.\r\n\r\n```php\r\n$query = new QueryBuilder();\r\n$query->aggregation(new TermsAggregation('name'));\r\n$products = Product::search($query);\r\n$buckets = $products->getAggregation('name');\r\n// Usage: $buckets[0]->getKey() and $buckets[0]->getCount()\r\n```\r\n\r\n### Parent-Child Relationship\r\n\r\nThe parent-child relationship is similar in nature to the nested model: both allow you to associate one entity with another. The difference is that, with nested objects, all entities live within the same document while, with parent-child, the parent and children are completely separate documents.\r\n\r\nLet's create two models:\r\n\r\n1. `PurchaseOrder` has many `PurchaseOrderLine` models\r\n2. `PurchaseOrderLine` belongs to `PurchaseOrder` model\r\n\r\n```php\r\nclass PurchaseOrder extends ElasticsearchModel\r\n{\r\n    protected static $_index = 'test_parent_child_rel';\r\n    protected static $_type = 'orders';\r\n\r\n    public $name;\r\n\r\n    public function lines()\r\n    {\r\n        return $this->hasMany(PurchaseOrderLine::class);\r\n    }\r\n}\r\n\r\nclass PurchaseOrderLine extends ElasticsearchModel\r\n{\r\n    protected static $_index = 'test_parent_child_rel';\r\n    protected static $_type = 'lines';\r\n    \r\n    protected static $_parentType = 'orders';\r\n\r\n    public $name;\r\n\r\n    public function po()\r\n    {\r\n        return $this->belongsTo(PurchaseOrder::class);\r\n    }\r\n}\r\n```\r\n\r\nTo `save()` models you can use the following code:\r\n\r\n```php\r\n$po = new PurchaseOrder(['id' => 1, 'name' => 'PO1']);\r\n$line = new PurchaseOrderLine(['id' => 1, 'name' => 'Line1']);\r\n\r\n$po->save();\r\n$po->lines()->save($line);\r\n```\r\n\r\nYou can use the `associate()` method to save models:\r\n\r\n```php\r\n$po = new PurchaseOrder(['id' => 1, 'name' => 'PO1']);\r\n$line = new PurchaseOrderLine(['id' => 1, 'name' => 'Line1']);\r\n\r\n$po->save();\r\n$line->po()->associate($po);\r\n$line->save();\r\n```\r\n\r\nTo get parent you can use the following code:\r\n\r\n```php\r\n$line = PurchaseOrderLine::findWithParentId(1, 1);\r\n$po = $line->po()->get();\r\n```\r\n\r\nTo get children you can use the following code:\r\n\r\n```php\r\n$po = PurchaseOrder::findOrFail(1);\r\n$line = $po->lines()->find(1); // by id\r\n$lines = $po->lines()->get(); // all children\r\n```\r\n\r\n### Inner hits\r\n\r\nThe parent/child and nested features allow the return of documents that have matches in a different scope. In the parent/child case, parent document are returned based on matches in child documents or child document are returned based on matches in parent documents. In the nested case, documents are returned based on matches in nested inner objects.\r\n\r\nYou can get parent model using only one request with `InnerHitsFilter` filter:\r\n\r\n```php\r\n$query = new QueryBuilder();\r\n$query->filter(new InnerHitsFilter(PurchaseOrderLine::getParentType()));\r\n$line = PurchaseOrderLine::search($query)->first();\r\n$po = $line->po()->get(); // will be retrieved from inner_hits cache\r\n```\r\n\r\n### Logging and data access layer events\r\n\r\nTo debug all elasticsearch queries to search you can use own `DALEmitter` class:\r\n\r\n```php\r\nuse Isswp101\\Persimmon\\DAL\\DALEvents;\r\nuse Isswp101\\Persimmon\\Event\\EventEmitter;\r\n\r\nclass DALEmitter extends EventEmitter\r\n{\r\n    public function __construct()\r\n    {\r\n        $this->on(DALEvents::BEFORE_SEARCH, function (array $params) {\r\n            Log::debug('Elasticsearch query', $params);\r\n        });\r\n    }\r\n}\r\n```\r\n\r\nAnd configure it in your service provider:\r\n\r\n```php\r\nuse Elasticsearch\\Client;\r\nuse Isswp101\\Persimmon\\DAL\\ElasticsearchDAL;\r\nuse Isswp101\\Persimmon\\ElasticsearchModel as Model;\r\nuse Isswp101\\Persimmon\\Test\\Models\\Events\\DALEmitter;\r\n\r\nclass ElasticsearchModel extends Model\r\n{\r\n    public function __construct(array $attributes = [])\r\n    {\r\n        $dal = new ElasticsearchDAL($this, app(Client::class), app(DALEmitter::class));\r\n\r\n        parent::__construct($dal, $attributes);\r\n    }\r\n    // ...\r\n}\r\n```\r\n\r\nThere are the following events:\r\n* `DALEvents::BEFORE_SEARCH` is triggered before any search.\r\n* `DALEvents::AFTER_SEARCH` is triggered after any search.\r\n\r\n**TO BE CONTINUED...**\r\n\r\n@TODO:\r\n* Add documentation about filters\r\n\r\n\r\n## Change log\r\n\r\nPlease see [CHANGELOG](CHANGELOG.md) for more information what has changed recently.\r\n\r\n## Testing\r\n\r\n``` bash\r\n$ composer test\r\n```\r\n\r\n## Contributing\r\n\r\nPlease see [CONTRIBUTING](CONTRIBUTING.md) and [CONDUCT](CONDUCT.md) for details.\r\n\r\n## Security\r\n\r\nIf you discover any security related issues, please email isswp101@gmail.com instead of using the issue tracker.\r\n\r\n## Credits\r\n\r\n- [Sergey Sorokin][link-author]\r\n- [All Contributors][link-contributors]\r\n\r\n## License\r\n\r\nThe MIT License (MIT). Please see [License File](LICENSE.md) for more information.\r\n\r\n[ico-version]: https://img.shields.io/packagist/v/isswp101/elasticsearch-eloquent.svg?style=flat-square\r\n[ico-license]: https://img.shields.io/badge/license-MIT-brightgreen.svg?style=flat-square\r\n[ico-travis]: https://img.shields.io/travis/isswp101/elasticsearch-eloquent/master.svg?style=flat-square\r\n[ico-scrutinizer]: https://img.shields.io/scrutinizer/coverage/g/isswp101/elasticsearch-eloquent.svg?style=flat-square\r\n[ico-code-quality]: https://img.shields.io/scrutinizer/g/isswp101/elasticsearch-eloquent.svg?style=flat-square\r\n[ico-downloads]: https://img.shields.io/packagist/dt/isswp101/elasticsearch-eloquent.svg?style=flat-square\r\n\r\n[link-packagist]: https://packagist.org/packages/isswp101/elasticsearch-eloquent\r\n[link-travis]: https://travis-ci.org/isswp101/elasticsearch-eloquent\r\n[link-scrutinizer]: https://scrutinizer-ci.com/g/isswp101/elasticsearch-eloquent/code-structure\r\n[link-code-quality]: https://scrutinizer-ci.com/g/isswp101/elasticsearch-eloquent\r\n[link-downloads]: https://packagist.org/packages/isswp101/elasticsearch-eloquent\r\n[link-author]: https://github.com/isswp101\r\n[link-contributors]: ../../contributors\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}